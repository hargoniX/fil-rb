@article{immutablebean,
  author       = {Sebastian Ullrich and
                  Leonardo de Moura},
  title        = {Counting Immutable Beans: Reference Counting Optimized for Purely
                  Functional Programming},
  journal      = {CoRR},
  volume       = {abs/1908.05647},
  year         = {2019},
  url          = {http://arxiv.org/abs/1908.05647},
  eprinttype    = {arXiv},
  eprint       = {1908.05647},
  timestamp    = {Thu, 29 Sep 2022 08:36:57 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-1908-05647.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{nipkowtrees,
author="Nipkow, Tobias",
editor="Blanchette, Jasmin Christian
and Merz, Stephan",
title="Automatic Functional Correctness Proofs for Functional Search Trees",
booktitle="Interactive Theorem Proving",
year="2016",
publisher="Springer International Publishing",
address="Cham",
pages="307--322",
abstract="In a new approach, functional correctness specifications of insert/update and delete operations on search trees are expressed on the level of lists by means of an inorder traversal function that projects trees to lists. With the help of a small lemma library, functional correctness and preservation of the search tree property are proved automatically (in Isabelle/HOL) for a range of data structures: unbalanced binary trees, AVL trees, red-black trees, 2-3 and 2-3-4 trees, 1-2 brother trees, AA trees and splay trees.",
isbn="978-3-319-43144-4"
}

@INPROCEEDINGS{rbtOriginal,
  author={Guibas, Leo J. and Sedgewick, Robert},
  booktitle={19th Annual Symposium on Foundations of Computer Science (sfcs 1978)},
  title={A dichromatic framework for balanced trees},
  year={1978},
  volume={},
  number={},
  pages={8-21},
  keywords={Computer science;Petroleum;Particle measurements;Algorithm design and analysis;Performance analysis},
  doi={10.1109/SFCS.1978.3}}

@article{Okasaki1999,
author = {Okasaki, Chris},
title = {Red-black trees in a functional setting},
year = {1999},
issue_date = {July 1999},
publisher = {Cambridge University Press},
address = {USA},
volume = {9},
number = {4},
issn = {0956-7968},
url = {https://doi.org/10.1017/S0956796899003494},
doi = {10.1017/S0956796899003494},
abstract = {Everybody learns about balanced binary search trees in their introductory computer science classes, but even the stouthearted tremble at the thought of actually implementing such a beast. The details surrounding rebalancing are usually just too messy. To show that this need not be the case, we present an algorithm for insertion into red-black trees (Guibas and Sedgewick, 1978) that any competent programmer should be able to implement in fifteen minutes or less.},
journal = {J. Funct. Program.},
month = jul,
pages = {471–477},
numpages = {7}
}

@book{fdc,
  title = "Functional Data Structures and Algorithms A Proof Assistant Approach
",
  author = "Nipkow et al, Tobias",
  year = 2024,
  address = "Munich",
  pages = "95-104",
}

@article{rbtDeletion,
author = {Kahrs, Stefan},
title = {Red-black trees with types},
year = {2001},
issue_date = {July 2001},
publisher = {Cambridge University Press},
address = {USA},
volume = {11},
number = {4},
issn = {0956-7968},
url = {https://doi.org/10.1017/S0956796801004026},
doi = {10.1017/S0956796801004026},
abstract = {Chris Okasaki showed how to implement red-black trees in a functional programming language. Ralf Hinze incorporated even the invariants of such data structures into their types, using higher-order nested datatypes. We show how one can achieve something very similar without the usual performance penalty of such types, by combining the features of nested datatypes, phantom types and existential type variables.},
journal = {J. Funct. Program.},
month = jul,
pages = {425–432},
numpages = {8}
}

@online{nipkowFDSA,
  author="Nipkow, Tobias",
  title = {Functional Data Structures and Algorithms},
  url = {https://functional-algorithms-verified.org/functional_data_structures_algorithms.pdf},
  urldate = "2025-02-27",
  year = "2024",
}

@online{leancorelib,
  title="Lean4 Core Library",
  url={https://github.com/leanprover/lean4/blob/master/src/Lean/Data/RBMap.lean},
  urldate = "2025-02-27",
  year="2019",
}

@inproceedings{aesop,
author = {Limperg, Jannis and From, Asta Halkj\ae{}r},
title = {Aesop: White-Box Best-First Proof Search for Lean},
year = {2023},
isbn = {9798400700262},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3573105.3575671},
doi = {10.1145/3573105.3575671},
abstract = {We present Aesop, a proof search tactic for the Lean 4 interactive
theorem prover. Aesop performs a tree-based search over a user-specified
set of proof rules. It supports safe and unsafe rules and uses a best-first
search strategy with customisable prioritisation. Aesop also allows users
to register custom normalisation rules and integrates Lean's simplifier to
support equational reasoning. Many details of Aesop's search procedure are
designed to make it a white-box proof automation tactic, meaning that users
should be able to easily predict how their rules will be applied, and thus how
powerful and fast their Aesop invocations will be.

Since we use a best-first search strategy, it is not obvious how to handle
metavariables which appear in multiple goals. The most common strategy for
dealing with metavariables relies on backtracking and is therefore not
suitable for best-first search. We give an algorithm which addresses this
issue. The algorithm works with any search strategy, is independent of the
underlying logic and makes few assumptions about how rules interact with
metavariables. We conjecture that with a fair search strategy, the algorithm
is as complete as the given set of rules allows.},
booktitle = {Proceedings of the 12th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {253–266},
numpages = {14},
keywords = {Lean, deductive verification, interactive theorem proving, proof search, tactic, type theory},
location = {Boston, MA, USA},
series = {CPP 2023}
}
